% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recover_omega_cov.R
\name{recover_omega_cov}
\alias{recover_omega_cov}
\title{Recover Omega-level covariance from Lambda-level Cholesky}
\usage{
recover_omega_cov(
  Llambda_int,
  Llambda_slope = NULL,
  mappingL1L2,
  method = c("structured", "pseudoinverse"),
  rho_int = 0,
  rho_slope = 0,
  intercept_var_fixed = TRUE,
  weights_normalize = TRUE
)
}
\arguments{
\item{Llambda_int}{nD x nD lower-triangular Cholesky for intercept block (Lambda)}

\item{Llambda_slope}{nD x nD lower-triangular Cholesky for slope block (Lambda). Can be NULL if no slopes.}

\item{mappingL1L2}{nD x nL matrix; entry (d, l) is the weight ω_{d,l} of Omega l in Lambda d.}

\item{method}{"structured" (default) or "pseudoinverse"}

\item{rho_int}{scalar or length nD vector of correlations within Omega block of each Lambda (intercepts)}

\item{rho_slope}{scalar or length nD vector (slopes). Ignored if Llambda_slope is NULL.}

\item{intercept_var_fixed}{if TRUE, force Var(Λ_d intercept)=1 even if Llambda_int implies something else.}

\item{weights_normalize}{if TRUE, normalize each row of mapping to sum to 1 (formative "weights sum to 1").}
}
\value{
A list with BOmega_int, BOmega_slope (if slopes), W, BLambda_int, BLambda_slope, diagnostics.
}
\description{
Recover Omega-level covariance from Lambda-level Cholesky
}
\examples{
 Example: nD = 2 Lambdas, nL = 3 Omegas
Λ1 uses Ω1, Ω2; Λ2 uses Ω3
mappingL1L2 <- rbind(
  c(1, 1, 0),   #' Λ1 <- Ω1, Ω2
  c(0, 0, 1)    #' Λ2 <- Ω3
)

#' Cholesky (lower-triangular) for Λ intercepts and slopes
Llambda_int <- matrix(c(
  1.0, 0.0,
  0.0, 0.7
), nrow = 2, byrow = TRUE)   #' diag(1, sqrt(0.7)) -> Var(Λ1_int)=1 (standardized), Var(Λ2_int)=0.49

Llambda_slope <- matrix(c(
  0.5, 0.0,
  0.1, 0.6
), nrow = 2, byrow = TRUE)
#' BLambda_slope = L L^T => will have off-diagonals since l21 != 0

#' Structured method: rho within Λ blocks (intercepts: 0; slopes: 0.2)
res_struct <- recover_omega_cov(
  Llambda_int   = Llambda_int,
  Llambda_slope = Llambda_slope,
  mappingL1L2   = mappingL1L2,
  method        = "structured",
  rho_int       = 0,
  rho_slope     = 0.2,
  intercept_var_fixed = TRUE,
  weights_normalize   = TRUE
)

res_struct$BOmega_int   #' 3x3 Ω-intercept covariance
res_struct$BOmega_slope #' 3x3 Ω-slope covariance (if provided)

#' Pseudoinverse fallback (matches Λ off-diagonals as much as possible)
res_pinv <- recover_omega_cov(
  Llambda_int   = Llambda_int,
  Llambda_slope = Llambda_slope,
  mappingL1L2   = mappingL1L2,
  method        = "pseudoinverse",
  intercept_var_fixed = TRUE,
  weights_normalize   = TRUE
)

res_pinv$BOmega_int
res_pinv$BOmega_slope
}
